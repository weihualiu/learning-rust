常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。
Rust 永远也不会自动创建数据的 “深拷贝”

如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用。
Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
作为一个通用的规则，任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。
move clone
Copy trait
borrowing 借用，原理是指向原变量的引用，并没有move或者clone
我们 也 不能在拥有不可变引用的同时拥有可变引用。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！
然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。

注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。

在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
引用必须总是有效的。

元组结构体 struct Color(i32,i32,i32);

关联函数经常被用作返回一个结构体新实例的构造函数。允许在 impl 块中定义 不 以 self 作为参数的函数

match 控制流运算符
